// Code generated by gqlclientgen - DO NOT EDIT

package mobilizon

import gqlclient "git.sr.ht/~emersion/gqlclient"

// An action log
type ActionLog struct {
	// Internal ID for this comment
	Id string `json:"id,omitempty"`
	// The actor that acted
	Actor *Actor `json:"actor,omitempty"`
	// The object that was acted upon
	Object *ActionLogObject `json:"object,omitempty"`
	// The action that was done
	Action *ActionLogAction `json:"action,omitempty"`
	// The time when the action was performed
	InsertedAt *DateTime `json:"insertedAt,omitempty"`
}

// The different types of action log actions
type ActionLogAction string

const (
	// The report was closed
	ActionLogActionReportUpdateClosed ActionLogAction = "REPORT_UPDATE_CLOSED"
	// The report was opened
	ActionLogActionReportUpdateOpened ActionLogAction = "REPORT_UPDATE_OPENED"
	// The report was resolved
	ActionLogActionReportUpdateResolved ActionLogAction = "REPORT_UPDATE_RESOLVED"
	// A note was created on a report
	ActionLogActionNoteCreation ActionLogAction = "NOTE_CREATION"
	// A note was deleted on a report
	ActionLogActionNoteDeletion ActionLogAction = "NOTE_DELETION"
	// An event was deleted
	ActionLogActionEventDeletion ActionLogAction = "EVENT_DELETION"
	// A comment was deleted
	ActionLogActionCommentDeletion ActionLogAction = "COMMENT_DELETION"
	// An event was updated
	ActionLogActionEventUpdate ActionLogAction = "EVENT_UPDATE"
	// An actor was suspended
	ActionLogActionActorSuspension ActionLogAction = "ACTOR_SUSPENSION"
	// An actor was unsuspended
	ActionLogActionActorUnsuspension ActionLogAction = "ACTOR_UNSUSPENSION"
	// An user was deleted
	ActionLogActionUserDeletion ActionLogAction = "USER_DELETION"
)

// The objects that can be in an action log
type ActionLogObject struct {
	// Internal ID for this object
	Id string `json:"id,omitempty"`
}

type Activity struct {
	// The activity item ID
	Id string `json:"id,omitempty"`
	// When was the activity inserted
	InsertedAt    *DateTime            `json:"insertedAt,omitempty"`
	Priority      *int32               `json:"priority,omitempty"`
	Type          *ActivityType        `json:"type,omitempty"`
	Subject       *string              `json:"subject,omitempty"`
	SubjectParams []*ActivityParamItem `json:"subjectParams,omitempty"`
	Message       *string              `json:"message,omitempty"`
	MessageParams []*ActivityParamItem `json:"messageParams,omitempty"`
	Object        *ActivityObject      `json:"object,omitempty"`
	Author        *Actor               `json:"author,omitempty"`
	Group         *Group               `json:"group,omitempty"`
}

type ActivityAuthor string

const (
	// Activities created by the current actor
	ActivityAuthorSelf ActivityAuthor = "SELF"
	// Activities created by others
	ActivityAuthorBy ActivityAuthor = "BY"
)

type ActivityObject struct {
	Id string `json:"id,omitempty"`
}

type ActivityParamItem struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

type ActivitySetting struct {
	Key     *string `json:"key,omitempty"`
	Method  *string `json:"method,omitempty"`
	Enabled *bool   `json:"enabled,omitempty"`
	User    *User   `json:"user,omitempty"`
}

type ActivityType string

const (
	// Activities concerning events
	ActivityTypeEvent ActivityType = "EVENT"
	// Activities concerning posts
	ActivityTypePost ActivityType = "POST"
	// Activities concerning discussions
	ActivityTypeDiscussion ActivityType = "DISCUSSION"
	// Activities concerning resources
	ActivityTypeResource ActivityType = "RESOURCE"
	// Activities concerning group settings
	ActivityTypeGroup ActivityType = "GROUP"
	// Activities concerning members
	ActivityTypeMember ActivityType = "MEMBER"
)

// An ActivityPub actor
type Actor struct {
	// Internal ID for this actor
	Id string `json:"id,omitempty"`
	// The ActivityPub actor's URL
	Url *string `json:"url,omitempty"`
	// The type of Actor (Person, Group,…)
	Type *ActorType `json:"type,omitempty"`
	// The actor's displayed name
	Name *string `json:"name,omitempty"`
	// The actor's domain if (null if it's this instance)
	Domain *string `json:"domain,omitempty"`
	// If the actor is from this instance
	Local *bool `json:"local,omitempty"`
	// The actor's summary
	Summary *string `json:"summary,omitempty"`
	// The actor's preferred username
	PreferredUsername *string `json:"preferredUsername,omitempty"`
	// Whether the actors manually approves followers
	ManuallyApprovesFollowers *bool `json:"manuallyApprovesFollowers,omitempty"`
	// If the actor is suspended
	Suspended *bool `json:"suspended,omitempty"`
	// The actor's avatar media
	Avatar *Media `json:"avatar,omitempty"`
	// The actor's banner media
	Banner *Media `json:"banner,omitempty"`
	// Number of followers for this actor
	FollowersCount *int32 `json:"followersCount,omitempty"`
	// Number of actors following this actor
	FollowingCount *int32 `json:"followingCount,omitempty"`
	// The total size of the media from this actor
	MediaSize *int32 `json:"mediaSize,omitempty"`
}

// The list of types an actor can be
type ActorType string

const (
	// An ActivityPub Person
	ActorTypePerson ActorType = "PERSON"
	// An ActivityPub Application
	ActorTypeApplication ActorType = "APPLICATION"
	// An ActivityPub Group
	ActorTypeGroup ActorType = "GROUP"
	// An ActivityPub Organization
	ActorTypeOrganization ActorType = "ORGANIZATION"
	// An ActivityPub Service
	ActorTypeService ActorType = "SERVICE"
)

// An address object
type Address struct {
	// The geocoordinates for the point where this address is
	Geom *Point `json:"geom,omitempty"`
	// The address's street name (with number)
	Street *string `json:"street,omitempty"`
	// The address's locality
	Locality *string `json:"locality,omitempty"`
	// The address's postal code
	PostalCode *string `json:"postalCode,omitempty"`
	// The address's region
	Region *string `json:"region,omitempty"`
	// The address's country
	Country *string `json:"country,omitempty"`
	// The address's description
	Description *string `json:"description,omitempty"`
	// The address's type
	Type *string `json:"type,omitempty"`
	// The address's URL
	Url *string `json:"url,omitempty"`
	// The address's ID
	Id string `json:"id,omitempty"`
	// The address's original ID from the provider
	OriginId *string `json:"originId,omitempty"`
	// The (estimated) timezone of the location
	Timezone *string `json:"timezone,omitempty"`
}

// An address input
type AddressInput struct {
	// The geocoordinates for the point where this address is
	Geom *Point `json:"geom,omitempty"`
	// The address's street name (with number)
	Street *string `json:"street,omitempty"`
	// The address's locality
	Locality *string `json:"locality,omitempty"`
	// The address's postal code
	PostalCode *string `json:"postalCode,omitempty"`
	// The address's region
	Region *string `json:"region,omitempty"`
	// The address's country
	Country *string `json:"country,omitempty"`
	// The address's description
	Description *string `json:"description,omitempty"`
	// The address's type
	Type *string `json:"type,omitempty"`
	// The address's URL
	Url *string `json:"url,omitempty"`
	// The address's ID
	Id string `json:"id,omitempty"`
	// The address's original ID from the provider
	OriginId *string `json:"originId,omitempty"`
	// The (estimated) timezone of the location
	Timezone *string `json:"timezone,omitempty"`
}

// A list of possible values for the type option to search an address.
//
// Results may vary depending on the geocoding provider.
type AddressSearchType string

const (
	// Administrative results (cities, regions,...)
	AddressSearchTypeAdministrative AddressSearchType = "ADMINISTRATIVE"
)

// Admin settings
type AdminSettings struct {
	// The instance's name
	InstanceName *string `json:"instanceName,omitempty"`
	// The instance's description
	InstanceDescription *string `json:"instanceDescription,omitempty"`
	// The instance's long description
	InstanceLongDescription *string `json:"instanceLongDescription,omitempty"`
	// The instance's slogan
	InstanceSlogan *string `json:"instanceSlogan,omitempty"`
	// The instance's contact details
	Contact *string `json:"contact,omitempty"`
	// The instance's terms body text
	InstanceTerms *string `json:"instanceTerms,omitempty"`
	// The instance's terms type
	InstanceTermsType *InstanceTermsType `json:"instanceTermsType,omitempty"`
	// The instance's terms URL
	InstanceTermsUrl *string `json:"instanceTermsUrl,omitempty"`
	// The instance's privacy policy body text
	InstancePrivacyPolicy *string `json:"instancePrivacyPolicy,omitempty"`
	// The instance's privacy policy type
	InstancePrivacyPolicyType *InstancePrivacyType `json:"instancePrivacyPolicyType,omitempty"`
	// The instance's privacy policy URL
	InstancePrivacyPolicyUrl *string `json:"instancePrivacyPolicyUrl,omitempty"`
	// The instance's rules
	InstanceRules *string `json:"instanceRules,omitempty"`
	// Whether the registrations are opened
	RegistrationsOpen *bool `json:"registrationsOpen,omitempty"`
	// The instance's languages
	InstanceLanguages []*string `json:"instanceLanguages,omitempty"`
}

type Analytics struct {
	// ID of the analytics service
	Id *string `json:"id,omitempty"`
	// Whether the service is activated or not
	Enabled *bool `json:"enabled,omitempty"`
	// A list of key-values configuration
	Configuration []*AnalyticsConfiguration `json:"configuration,omitempty"`
}

type AnalyticsConfiguration struct {
	// The key for the analytics configuration element
	Key *string `json:"key,omitempty"`
	// The value for the analytics configuration element
	Value *string `json:"value,omitempty"`
	// The analytics configuration type
	Type *AnalyticsConfigurationType `json:"type,omitempty"`
}

type AnalyticsConfigurationType string

const (
	// A string
	AnalyticsConfigurationTypeString AnalyticsConfigurationType = "STRING"
	// An integer
	AnalyticsConfigurationTypeInteger AnalyticsConfigurationType = "INTEGER"
	// A boolean
	AnalyticsConfigurationTypeBoolean AnalyticsConfigurationType = "BOOLEAN"
	// A float
	AnalyticsConfigurationTypeFloat AnalyticsConfigurationType = "FLOAT"
)

// Instance anonymous configuration
type Anonymous struct {
	// The instance's anonymous participation settings
	Participation *AnonymousParticipation `json:"participation,omitempty"`
	// The instance's anonymous event creation settings
	EventCreation *AnonymousEventCreation `json:"eventCreation,omitempty"`
	// The instance's anonymous reports setting
	Reports *AnonymousReports `json:"reports,omitempty"`
	// The actor ID that should be used to perform anonymous actions
	ActorId string `json:"actorId,omitempty"`
}

// Instance anonymous event creation configuration
type AnonymousEventCreation struct {
	// Whether anonymous event creation is enabled
	Allowed *bool `json:"allowed,omitempty"`
	// The methods to validate events created anonymously
	Validation *AnonymousEventCreationValidation `json:"validation,omitempty"`
}

// Instance anonymous event creation validation configuration
type AnonymousEventCreationValidation struct {
	// The policy to validate anonymous event creations by email
	Email *AnonymousEventCreationValidationEmail `json:"email,omitempty"`
	// The policy to validate anonymous event creations by captcha
	Captcha *AnonymousEventCreationValidationCaptcha `json:"captcha,omitempty"`
}

// Instance anonymous event creation captcha validation configuration
type AnonymousEventCreationValidationCaptcha struct {
	// Whether anonymous event creation with validation by captcha is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

// Instance anonymous event creation email validation configuration
type AnonymousEventCreationValidationEmail struct {
	// Whether anonymous event creation with email validation is enabled
	Enabled *bool `json:"enabled,omitempty"`
	// Whether anonymous event creation with email validation is required
	ConfirmationRequired *bool `json:"confirmationRequired,omitempty"`
}

// Instance anonymous participation configuration
type AnonymousParticipation struct {
	// Whether anonymous participations are allowed
	Allowed *bool `json:"allowed,omitempty"`
	// The ways to validate anonymous participations
	Validation *AnonymousParticipationValidation `json:"validation,omitempty"`
}

// Instance anonymous participation validation configuration
type AnonymousParticipationValidation struct {
	// The policy to validate anonymous participations by email
	Email *AnonymousParticipationValidationEmail `json:"email,omitempty"`
	// The policy to validate anonymous participations by captcha
	Captcha *AnonymousParticipationValidationCaptcha `json:"captcha,omitempty"`
}

// Instance anonymous participation with validation by captcha configuration
type AnonymousParticipationValidationCaptcha struct {
	// Whether anonymous participation validation by captcha is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

// Instance anonymous participation with validation by email configuration
type AnonymousParticipationValidationEmail struct {
	// Whether anonymous participation validation by email is enabled
	Enabled *bool `json:"enabled,omitempty"`
	// Whether anonymous participation validation by email is required
	ConfirmationRequired *bool `json:"confirmationRequired,omitempty"`
}

// Instance anonymous reports
type AnonymousReports struct {
	// Whether anonymous reports are allowed
	Allowed *bool `json:"allowed,omitempty"`
}

// Represents an application
type Application struct {
	// Internal ID for this application
	Id string `json:"id,omitempty"`
	// The ActivityPub actor's URL
	Url *string `json:"url,omitempty"`
	// The type of Actor (Person, Group,…)
	Type *ActorType `json:"type,omitempty"`
	// The actor's displayed name
	Name *string `json:"name,omitempty"`
	// The actor's domain if (null if it's this instance)
	Domain *string `json:"domain,omitempty"`
	// If the actor is from this instance
	Local *bool `json:"local,omitempty"`
	// The actor's summary
	Summary *string `json:"summary,omitempty"`
	// The actor's preferred username
	PreferredUsername *string `json:"preferredUsername,omitempty"`
	// Whether the actors manually approves followers
	ManuallyApprovesFollowers *bool `json:"manuallyApprovesFollowers,omitempty"`
	// If the actor is suspended
	Suspended *bool `json:"suspended,omitempty"`
	// The actor's avatar media
	Avatar *Media `json:"avatar,omitempty"`
	// The actor's banner media
	Banner *Media `json:"banner,omitempty"`
	// Number of followers for this actor
	FollowersCount *int32 `json:"followersCount,omitempty"`
	// Number of actors following this actor
	FollowingCount *int32 `json:"followingCount,omitempty"`
	// The total size of the media from this actor
	MediaSize *int32 `json:"mediaSize,omitempty"`
}

// The instance's auth configuration
type Auth struct {
	// Whether or not LDAP auth is enabled
	Ldap *bool `json:"ldap,omitempty"`
	// List of oauth providers
	OauthProviders []*OauthProvider `json:"oauthProviders,omitempty"`
}

// A comment
type Comment struct {
	// Internal ID for this comment
	Id string `json:"id,omitempty"`
	// An UUID for this comment
	Uuid *UUID `json:"uuid,omitempty"`
	// Comment URL
	Url *string `json:"url,omitempty"`
	// Whether this comment is local or not
	Local *bool `json:"local,omitempty"`
	// The visibility for the comment
	Visibility *CommentVisibility `json:"visibility,omitempty"`
	// The comment body
	Text *string `json:"text,omitempty"`
	// The comment's primary language
	PrimaryLanguage *string `json:"primaryLanguage,omitempty"`
	// A list of replies to the comment
	Replies []*Comment `json:"replies,omitempty"`
	// The number of total known replies to this comment
	TotalReplies *int32 `json:"totalReplies,omitempty"`
	// The comment this comment directly replies to
	InReplyToComment *Comment `json:"inReplyToComment,omitempty"`
	// The eventual event this comment is under
	Event *Event `json:"event,omitempty"`
	// The original comment that started the thread this comment is in
	OriginComment *Comment `json:"originComment,omitempty"`
	// The thread languages
	ThreadLanguages []*string `json:"threadLanguages"`
	// The comment's author
	Actor *Person `json:"actor,omitempty"`
	// When was the comment inserted in database
	InsertedAt *DateTime `json:"insertedAt,omitempty"`
	// When was the comment updated
	UpdatedAt *DateTime `json:"updatedAt,omitempty"`
	// When was the comment deleted
	DeletedAt *DateTime `json:"deletedAt,omitempty"`
	// When was the comment published
	PublishedAt *DateTime `json:"publishedAt,omitempty"`
	// Whether this comment needs to be announced to participants
	IsAnnouncement bool `json:"isAnnouncement"`
	// The comment language
	Language *string `json:"language,omitempty"`
}

// The list of visibility options for a comment
type CommentVisibility string

const (
	// Publicly listed and federated. Can be shared.
	CommentVisibilityPublic CommentVisibility = "PUBLIC"
	// Visible only to people with the link - or invited
	CommentVisibilityUnlisted CommentVisibility = "UNLISTED"
	// Visible only to people members of the group or followers of the person
	CommentVisibilityPrivate CommentVisibility = "PRIVATE"
	// Visible only after a moderator accepted
	CommentVisibilityModerated CommentVisibility = "MODERATED"
	// visible only to people invited
	CommentVisibilityInvite CommentVisibility = "INVITE"
)

// A config object
type Config struct {
	// The instance's name
	Name *string `json:"name,omitempty"`
	// The instance's short description
	Description *string `json:"description,omitempty"`
	// The instance's long description
	LongDescription *string `json:"longDescription,omitempty"`
	// The instance's slogan
	Slogan *string `json:"slogan,omitempty"`
	// The instance's contact details
	Contact *string `json:"contact,omitempty"`
	// The instance's admins languages
	Languages []*string `json:"languages,omitempty"`
	// The instance list of event categories possibilities
	EventCategories []*EventCategoryOption `json:"eventCategories,omitempty"`
	// Whether the registrations are opened
	RegistrationsOpen *bool `json:"registrationsOpen,omitempty"`
	// Whether the registration are on an allowlist
	RegistrationsAllowlist *bool `json:"registrationsAllowlist,omitempty"`
	// Whether the demo mode is enabled
	DemoMode *bool `json:"demoMode,omitempty"`
	// The country code from the IP
	CountryCode *string `json:"countryCode,omitempty"`
	// The IP's location
	Location *Lonlat `json:"location,omitempty"`
	// The instance's geocoding settings
	Geocoding *Geocoding `json:"geocoding,omitempty"`
	// The instance's maps settings
	Maps *Maps `json:"maps,omitempty"`
	// The instance's anonymous action settings
	Anonymous *Anonymous `json:"anonymous,omitempty"`
	// The instance's enabled resource providers
	ResourceProviders []*ResourceProvider `json:"resourceProviders,omitempty"`
	// The configuration for upload limits
	UploadLimits *UploadLimits `json:"uploadLimits,omitempty"`
	// The instance's available timezones
	Timezones []*string `json:"timezones,omitempty"`
	// The instance's features
	Features *Features `json:"features,omitempty"`
	// The instance's restrictions
	Restrictions *Restrictions `json:"restrictions,omitempty"`
	// The instance's version
	Version *string `json:"version,omitempty"`
	// Whether this instance is federation
	Federating *bool `json:"federating,omitempty"`
	// The instance's terms
	Terms *Terms `json:"terms,omitempty"`
	// The instance's privacy policy
	Privacy *Privacy `json:"privacy,omitempty"`
	// The instance's rules
	Rules *string `json:"rules,omitempty"`
	// The instance auth methods
	Auth *Auth `json:"auth,omitempty"`
	// The instance's feed settings
	InstanceFeeds *InstanceFeeds `json:"instanceFeeds,omitempty"`
	// Web Push settings for the instance
	WebPush *WebPush `json:"webPush,omitempty"`
	// The instance list of export formats
	ExportFormats *ExportFormats `json:"exportFormats,omitempty"`
	// Configuration for diverse analytics services
	Analytics []*Analytics `json:"analytics,omitempty"`
}

// A event contact
type Contact struct {
	// The Contact Actor ID
	Id *string `json:"id,omitempty"`
}

// Dashboard information
type Dashboard struct {
	// Last public event published
	LastPublicEventPublished *Event `json:"lastPublicEventPublished,omitempty"`
	// Last public group created
	LastGroupCreated *Group `json:"lastGroupCreated,omitempty"`
	// The number of local users
	NumberOfUsers *int32 `json:"numberOfUsers,omitempty"`
	// The number of local events
	NumberOfEvents *int32 `json:"numberOfEvents,omitempty"`
	// The number of local comments
	NumberOfComments *int32 `json:"numberOfComments,omitempty"`
	// The number of local groups
	NumberOfGroups *int32 `json:"numberOfGroups,omitempty"`
	// The number of current opened reports
	NumberOfReports *int32 `json:"numberOfReports,omitempty"`
	// The number of instance followers
	NumberOfFollowers *int32 `json:"numberOfFollowers,omitempty"`
	// The number of instance followings
	NumberOfFollowings *int32 `json:"numberOfFollowings,omitempty"`
	// The number of total confirmed participations to local events
	NumberOfConfirmedParticipationsToLocalEvents *int32 `json:"numberOfConfirmedParticipationsToLocalEvents,omitempty"`
}

// The `DateTime` scalar type represents a date and time in the UTC
// timezone. The DateTime appears in a JSON response as an ISO8601 formatted
// string, including UTC timezone ("Z"). The parsed date and time string will
// be converted to UTC if there is an offset.
type DateTime string

// Represents a deleted feed_token
type DeletedFeedToken struct {
	// The user that owned the deleted feed token
	User *DeletedObject `json:"user,omitempty"`
	// The actor that owned the deleted feed token
	Actor *DeletedObject `json:"actor,omitempty"`
}

// A struct containing the id of the deleted object
type DeletedObject struct {
	Id string `json:"id,omitempty"`
}

// Represents a deleted participant
type DeletedParticipant struct {
	// The participant ID
	Id string `json:"id,omitempty"`
	// The participant's event
	Event *DeletedObject `json:"event,omitempty"`
	// The participant's actor
	Actor *DeletedObject `json:"actor,omitempty"`
}

// A discussion
type Discussion struct {
	// Internal ID for this discussion
	Id string `json:"id,omitempty"`
	// The title for this discussion
	Title *string `json:"title,omitempty"`
	// The slug for the discussion
	Slug *string `json:"slug,omitempty"`
	// The last comment of the discussion
	LastComment *Comment `json:"lastComment,omitempty"`
	// The comments for the discussion
	Comments *PaginatedCommentList `json:"comments,omitempty"`
	// This discussions's creator
	Creator *Person `json:"creator,omitempty"`
	// This discussion's group
	Actor *Actor `json:"actor,omitempty"`
	// When was this discussion's created
	InsertedAt *DateTime `json:"insertedAt,omitempty"`
	// When was this discussion's updated
	UpdatedAt *DateTime `json:"updatedAt,omitempty"`
}

// An event
type Event struct {
	// Internal ID for this event
	Id string `json:"id,omitempty"`
	// The Event UUID
	Uuid *UUID `json:"uuid,omitempty"`
	// The ActivityPub Event URL
	Url *string `json:"url,omitempty"`
	// Whether the event is local or not
	Local *bool `json:"local,omitempty"`
	// The event's title
	Title *string `json:"title,omitempty"`
	// The event's description's slug
	Slug *string `json:"slug,omitempty"`
	// The event's description
	Description *string `json:"description,omitempty"`
	// Datetime for when the event begins
	BeginsOn *DateTime `json:"beginsOn,omitempty"`
	// Datetime for when the event ends
	EndsOn *DateTime `json:"endsOn,omitempty"`
	// Status of the event
	Status *EventStatus `json:"status,omitempty"`
	// The event's visibility
	Visibility *EventVisibility `json:"visibility,omitempty"`
	// The event's visibility
	JoinOptions *EventJoinOptions `json:"joinOptions,omitempty"`
	// External URL for participation
	ExternalParticipationUrl *string `json:"externalParticipationUrl,omitempty"`
	// The event's picture
	Picture *Media `json:"picture,omitempty"`
	// The event's media
	Media []*Media `json:"media,omitempty"`
	// When the event was published
	PublishAt *DateTime `json:"publishAt,omitempty"`
	// The event's physical address
	PhysicalAddress *Address `json:"physicalAddress,omitempty"`
	// Online address of the event
	OnlineAddress *string `json:"onlineAddress,omitempty"`
	// Phone address for the event
	PhoneAddress *string `json:"phoneAddress,omitempty"`
	// Who the event is attributed to (often a group)
	AttributedTo *Actor `json:"attributedTo,omitempty"`
	// The event's organizer (as a person)
	OrganizerActor *Actor `json:"organizerActor,omitempty"`
	// The event's tags
	Tags []*Tag `json:"tags,omitempty"`
	// The event's category
	Category *EventCategory `json:"category,omitempty"`
	// Whether or not the event is a draft
	Draft *bool `json:"draft,omitempty"`
	// Statistics on the event
	ParticipantStats *ParticipantStats `json:"participantStats,omitempty"`
	// The event's participants
	Participants *PaginatedParticipantList `json:"participants,omitempty"`
	// The events contacts
	Contacts []*Actor `json:"contacts,omitempty"`
	// Events related to this one
	RelatedEvents []*Event `json:"relatedEvents,omitempty"`
	// The comments in reply to the event
	Comments []*Comment `json:"comments,omitempty"`
	// When the event was last updated
	UpdatedAt *DateTime `json:"updatedAt,omitempty"`
	// When the event was created
	InsertedAt *DateTime `json:"insertedAt,omitempty"`
	// The event options
	Options *EventOptions `json:"options,omitempty"`
	// A key-value list of metadata
	Metadata []*EventMetadata `json:"metadata,omitempty"`
	// The event language
	Language *string `json:"language,omitempty"`
}

type EventCategory string

const (
	EventCategoryArts                        EventCategory = "ARTS"
	EventCategoryBookClubs                   EventCategory = "BOOK_CLUBS"
	EventCategoryBusiness                    EventCategory = "BUSINESS"
	EventCategoryCauses                      EventCategory = "CAUSES"
	EventCategoryComedy                      EventCategory = "COMEDY"
	EventCategoryCrafts                      EventCategory = "CRAFTS"
	EventCategoryFoodDrink                   EventCategory = "FOOD_DRINK"
	EventCategoryHealth                      EventCategory = "HEALTH"
	EventCategoryMusic                       EventCategory = "MUSIC"
	EventCategoryAutoBoatAir                 EventCategory = "AUTO_BOAT_AIR"
	EventCategoryCommunity                   EventCategory = "COMMUNITY"
	EventCategoryFamilyEducation             EventCategory = "FAMILY_EDUCATION"
	EventCategoryFashionBeauty               EventCategory = "FASHION_BEAUTY"
	EventCategoryFilmMedia                   EventCategory = "FILM_MEDIA"
	EventCategoryGames                       EventCategory = "GAMES"
	EventCategoryLanguageCulture             EventCategory = "LANGUAGE_CULTURE"
	EventCategoryLearning                    EventCategory = "LEARNING"
	EventCategoryLgbtq                       EventCategory = "LGBTQ"
	EventCategoryMovementsPolitics           EventCategory = "MOVEMENTS_POLITICS"
	EventCategoryNetworking                  EventCategory = "NETWORKING"
	EventCategoryParty                       EventCategory = "PARTY"
	EventCategoryPerformingVisualArts        EventCategory = "PERFORMING_VISUAL_ARTS"
	EventCategoryPets                        EventCategory = "PETS"
	EventCategoryPhotography                 EventCategory = "PHOTOGRAPHY"
	EventCategoryOutdoorsAdventure           EventCategory = "OUTDOORS_ADVENTURE"
	EventCategorySpiritualityReligionBeliefs EventCategory = "SPIRITUALITY_RELIGION_BELIEFS"
	EventCategoryScienceTech                 EventCategory = "SCIENCE_TECH"
	EventCategorySports                      EventCategory = "SPORTS"
	EventCategoryTheatre                     EventCategory = "THEATRE"
	EventCategoryMeeting                     EventCategory = "MEETING"
)

// Event categories list configuration
type EventCategoryOption struct {
	// The ID of the event category
	Id *string `json:"id,omitempty"`
	// The translated name of the event category
	Label *string `json:"label,omitempty"`
}

// The list of possible options for the event's status
type EventCommentModeration string

const (
	// Anyone can comment under the event
	EventCommentModerationAllowAll EventCommentModeration = "ALLOW_ALL"
	// Every comment has to be moderated by the admin
	EventCommentModerationModerated EventCommentModeration = "MODERATED"
	// No one can comment except for the admin
	EventCommentModerationClosed EventCommentModeration = "CLOSED"
)

// The list of join options for an event
type EventJoinOptions string

const (
	// Anyone can join and is automatically accepted
	EventJoinOptionsFree EventJoinOptions = "FREE"
	// Manual acceptation
	EventJoinOptionsRestricted EventJoinOptions = "RESTRICTED"
	// Participants must be invited
	EventJoinOptionsInvite EventJoinOptions = "INVITE"
	// External registration
	EventJoinOptionsExternal EventJoinOptions = "EXTERNAL"
)

type EventMetadata struct {
	// The key for the metadata
	Key *string `json:"key,omitempty"`
	// The title for the metadata
	Title *string `json:"title,omitempty"`
	// The value for the metadata
	Value *string `json:"value,omitempty"`
	// The metadata type
	Type *EventMetadataType `json:"type,omitempty"`
}

type EventMetadataInput struct {
	// The key for the metadata
	Key string `json:"key"`
	// The title for the metadata
	Title *string `json:"title,omitempty"`
	// The value for the metadata
	Value string `json:"value"`
	// The metadata type
	Type *EventMetadataType `json:"type,omitempty"`
}

type EventMetadataType string

const (
	// A string
	EventMetadataTypeString EventMetadataType = "STRING"
	// An integer
	EventMetadataTypeInteger EventMetadataType = "INTEGER"
	// A boolean
	EventMetadataTypeBoolean EventMetadataType = "BOOLEAN"
)

// An event offer
type EventOffer struct {
	// The price amount for this offer
	Price *float64 `json:"price,omitempty"`
	// The currency for this price offer
	PriceCurrency *string `json:"priceCurrency,omitempty"`
	// The URL to access to this offer
	Url *string `json:"url,omitempty"`
}

// An event offer
type EventOfferInput struct {
	// The price amount for this offer
	Price *float64 `json:"price,omitempty"`
	// The currency for this price offer
	PriceCurrency *string `json:"priceCurrency,omitempty"`
	// The URL to access to this offer
	Url *string `json:"url,omitempty"`
}

// Event options
type EventOptions struct {
	// The maximum attendee capacity for this event
	MaximumAttendeeCapacity *int32 `json:"maximumAttendeeCapacity,omitempty"`
	// The number of remaining seats for this event
	RemainingAttendeeCapacity *int32 `json:"remainingAttendeeCapacity,omitempty"`
	// Whether or not to show the number of remaining seats for this event
	ShowRemainingAttendeeCapacity *bool `json:"showRemainingAttendeeCapacity,omitempty"`
	// Whether or not to allow anonymous participation (if the server allows it)
	AnonymousParticipation *bool `json:"anonymousParticipation,omitempty"`
	// The list of offers to show for this event
	Offers []*EventOffer `json:"offers,omitempty"`
	// The list of participation conditions to accept to join this event
	ParticipationConditions []*EventParticipationCondition `json:"participationConditions,omitempty"`
	// The list of special attendees
	Attendees []*string `json:"attendees,omitempty"`
	// The list of the event
	Program *string `json:"program,omitempty"`
	// The policy on public comment moderation under the event
	CommentModeration *EventCommentModeration `json:"commentModeration,omitempty"`
	// Whether or not to show the participation price
	ShowParticipationPrice *bool `json:"showParticipationPrice,omitempty"`
	// Show event start time
	ShowStartTime *bool `json:"showStartTime,omitempty"`
	// Show event end time
	ShowEndTime *bool `json:"showEndTime,omitempty"`
	// The event's timezone
	Timezone *string `json:"timezone,omitempty"`
	// Whether to show or hide the person organizer when event is organized by a group
	HideOrganizerWhenGroupEvent *bool `json:"hideOrganizerWhenGroupEvent,omitempty"`
	// Whether the event is fully online
	IsOnline *bool `json:"isOnline,omitempty"`
}

// Event options
type EventOptionsInput struct {
	// The maximum attendee capacity for this event
	MaximumAttendeeCapacity *int32 `json:"maximumAttendeeCapacity,omitempty"`
	// The number of remaining seats for this event
	RemainingAttendeeCapacity *int32 `json:"remainingAttendeeCapacity,omitempty"`
	// Whether or not to show the number of remaining seats for this event
	ShowRemainingAttendeeCapacity *bool `json:"showRemainingAttendeeCapacity,omitempty"`
	// Whether or not to allow anonymous participation (if the server allows it)
	AnonymousParticipation *bool `json:"anonymousParticipation,omitempty"`
	// The list of offers to show for this event
	Offers []*EventOfferInput `json:"offers,omitempty"`
	// The list of participation conditions to accept to join this event
	ParticipationConditions []*EventParticipationConditionInput `json:"participationConditions,omitempty"`
	// The list of special attendees
	Attendees []*string `json:"attendees,omitempty"`
	// The list of the event
	Program *string `json:"program,omitempty"`
	// The policy on public comment moderation under the event
	CommentModeration *EventCommentModeration `json:"commentModeration,omitempty"`
	// Whether or not to show the participation price
	ShowParticipationPrice *bool `json:"showParticipationPrice,omitempty"`
	// Show event start time
	ShowStartTime *bool `json:"showStartTime,omitempty"`
	// Show event end time
	ShowEndTime *bool `json:"showEndTime,omitempty"`
	// The event's timezone
	Timezone *string `json:"timezone,omitempty"`
	// Whether to show or hide the person organizer when event is organized by a group
	HideOrganizerWhenGroupEvent *bool `json:"hideOrganizerWhenGroupEvent,omitempty"`
	// Whether the event is fully online
	IsOnline *bool `json:"isOnline,omitempty"`
}

// Available event sort fields
type EventOrderBy string

const (
	// Sort by the date the event starts
	EventOrderByBeginsOn EventOrderBy = "BEGINS_ON"
	// Sort by the date the event was created
	EventOrderByInsertedAt EventOrderBy = "INSERTED_AT"
	// Sort by the date the event was updated
	EventOrderByUpdatedAt EventOrderBy = "UPDATED_AT"
)

// An event participation condition
type EventParticipationCondition struct {
	// The title for this condition
	Title *string `json:"title,omitempty"`
	// The content for this condition
	Content *string `json:"content,omitempty"`
	// The URL to access this condition
	Url *string `json:"url,omitempty"`
}

// An event participation condition
type EventParticipationConditionInput struct {
	// The title for this condition
	Title *string `json:"title,omitempty"`
	// The content for this condition
	Content *string `json:"content,omitempty"`
	// The URL to access this condition
	Url *string `json:"url,omitempty"`
}

// The list of possible options for the event's status
type EventStatus string

const (
	// The event is tentative
	EventStatusTentative EventStatus = "TENTATIVE"
	// The event is confirmed
	EventStatusConfirmed EventStatus = "CONFIRMED"
	// The event is cancelled
	EventStatusCancelled EventStatus = "CANCELLED"
)

type EventType string

const (
	// The event will happen in person. It can also be livestreamed, but has a physical address
	EventTypeInPerson EventType = "IN_PERSON"
	// The event will only happen online. It has no physical address
	EventTypeOnline EventType = "ONLINE"
)

// The list of visibility options for an event
type EventVisibility string

const (
	// Publicly listed and federated. Can be shared.
	EventVisibilityPublic EventVisibility = "PUBLIC"
	// Visible only to people with the link - or invited
	EventVisibilityUnlisted EventVisibility = "UNLISTED"
	// Visible only after a moderator accepted
	EventVisibilityRestricted EventVisibility = "RESTRICTED"
	// Visible only to people members of the group or followers of the person
	EventVisibilityPrivate EventVisibility = "PRIVATE"
)

// Search events result
type Events struct {
	// Total elements
	Total int32 `json:"total"`
	// Event elements
	Elements []*Event `json:"elements"`
}

type ExportFormatEnum string

const (
	// CSV format
	ExportFormatEnumCsv ExportFormatEnum = "CSV"
	// PDF format
	ExportFormatEnumPdf ExportFormatEnum = "PDF"
	// ODS format
	ExportFormatEnumOds ExportFormatEnum = "ODS"
)

// Export formats configuration
type ExportFormats struct {
	// The list of formats the event participants can be exported to
	EventParticipants []*string `json:"eventParticipants,omitempty"`
}

// The instance's features
type Features struct {
	// Whether groups are activated on this instance
	Groups *bool `json:"groups,omitempty"`
	// Whether event creation is allowed on this instance
	EventCreation *bool `json:"eventCreation,omitempty"`
}

// Represents a feed token
//
// Feed tokens are tokens that are used to provide access to private feeds such as WebCal feed for all of your user's events,
// or an Atom feed for just a profile.
type FeedToken struct {
	// The event which the actor participates in
	Actor *Actor `json:"actor,omitempty"`
	// The actor that participates to the event
	User *User `json:"user,omitempty"`
	// A ShortUUID private token
	Token *string `json:"token,omitempty"`
}

// A follow group event
type FollowedGroupEvent struct {
	User    *User   `json:"user,omitempty"`
	Profile *Person `json:"profile,omitempty"`
	Group   *Group  `json:"group,omitempty"`
	Event   *Event  `json:"event,omitempty"`
}

// Represents an actor's follower
type Follower struct {
	// The follow ID
	Id string `json:"id,omitempty"`
	// What or who the profile follows
	TargetActor *Actor `json:"targetActor,omitempty"`
	// Which profile follows
	Actor *Actor `json:"actor,omitempty"`
	// Whether the follow has been approved by the target actor
	Approved *bool `json:"approved,omitempty"`
	// Whether the follower will be notified by the target actor's activity or not (applicable for profile/group follows)
	Notify *bool `json:"notify,omitempty"`
	// When the follow was created
	InsertedAt *DateTime `json:"insertedAt,omitempty"`
	// When the follow was updated
	UpdatedAt *DateTime `json:"updatedAt,omitempty"`
}

// Instance geocoding configuration
type Geocoding struct {
	// Whether autocomplete in address fields can be enabled
	Autocomplete *bool `json:"autocomplete,omitempty"`
	// The geocoding provider
	Provider *string `json:"provider,omitempty"`
}

// Represents a group of actors
type Group struct {
	// Internal ID for this group
	Id string `json:"id,omitempty"`
	// The ActivityPub actor's URL
	Url *string `json:"url,omitempty"`
	// The type of Actor (Person, Group,…)
	Type *ActorType `json:"type,omitempty"`
	// The actor's displayed name
	Name *string `json:"name,omitempty"`
	// The actor's domain if (null if it's this instance)
	Domain *string `json:"domain,omitempty"`
	// If the actor is from this instance
	Local *bool `json:"local,omitempty"`
	// The actor's summary
	Summary *string `json:"summary,omitempty"`
	// The actor's preferred username
	PreferredUsername *string `json:"preferredUsername,omitempty"`
	// Whether the actors manually approves followers
	ManuallyApprovesFollowers *bool `json:"manuallyApprovesFollowers,omitempty"`
	// Whether the group can be found and/or promoted
	Visibility *GroupVisibility `json:"visibility,omitempty"`
	// If the actor is suspended
	Suspended *bool `json:"suspended,omitempty"`
	// The actor's avatar media
	Avatar *Media `json:"avatar,omitempty"`
	// The actor's banner media
	Banner *Media `json:"banner,omitempty"`
	// The type of the event's address
	PhysicalAddress *Address `json:"physicalAddress,omitempty"`
	// Number of followers for this actor
	FollowersCount *int32 `json:"followersCount,omitempty"`
	// Number of actors following this actor
	FollowingCount *int32 `json:"followingCount,omitempty"`
	// The total size of the media from this actor
	MediaSize *int32 `json:"mediaSize,omitempty"`
	// A list of the events this actor has organized
	OrganizedEvents *PaginatedEventList `json:"organizedEvents,omitempty"`
	// A list of the discussions for this group
	Discussions *PaginatedDiscussionList `json:"discussions,omitempty"`
	// The type of group : Group, Community,…
	Types *GroupType `json:"types,omitempty"`
	// Whether the group is opened to all or has restricted access
	Openness *Openness `json:"openness,omitempty"`
	// A paginated list of group members
	Members *PaginatedMemberList `json:"members,omitempty"`
	// A paginated list of the resources this group has
	Resources *PaginatedResourceList `json:"resources,omitempty"`
	// A paginated list of the posts this group has
	Posts *PaginatedPostList `json:"posts,omitempty"`
	// A paginated list of the todo lists this group has
	TodoLists *PaginatedTodoListList `json:"todoLists,omitempty"`
	// A paginated list of the followers this group has
	Followers *PaginatedFollowerList `json:"followers,omitempty"`
	// The group activity
	Activity *PaginatedActivityList `json:"activity,omitempty"`
}

// The types of Group that exist
type GroupType string

const (
	// A private group of persons
	GroupTypeGroup GroupType = "GROUP"
	// A public group of many actors
	GroupTypeCommunity GroupType = "COMMUNITY"
)

// The list of visibility options for a group
type GroupVisibility string

const (
	// Publicly listed and federated
	GroupVisibilityPublic GroupVisibility = "PUBLIC"
	// Visible only to people with the link - or invited
	GroupVisibilityUnlisted GroupVisibility = "UNLISTED"
	// Visible only to people with the link - or invited
	GroupVisibilityPrivate GroupVisibility = "PRIVATE"
)

// Search groups result
type Groups struct {
	// Total elements
	Total int32 `json:"total"`
	// Group elements
	Elements []*Group `json:"elements"`
}

// An instance representation
type Instance struct {
	// The domain name of the instance
	Domain string `json:"domain,omitempty"`
	// Do we follow this instance
	FollowerStatus *InstanceFollowStatus `json:"followerStatus,omitempty"`
	// Does this instance follow us?
	FollowedStatus *InstanceFollowStatus `json:"followedStatus,omitempty"`
	// The number of events on this instance we know of
	EventCount *int32 `json:"eventCount,omitempty"`
	// The number of profiles on this instance we know of
	PersonCount *int32 `json:"personCount,omitempty"`
	// The number of grouo on this instance we know of
	GroupCount *int32 `json:"groupCount,omitempty"`
	// The number of their profiles who follow our groups
	FollowersCount *int32 `json:"followersCount,omitempty"`
	// The number of our profiles who follow their groups
	FollowingsCount *int32 `json:"followingsCount,omitempty"`
	// The number of reports made against profiles from this instance
	ReportsCount *int32 `json:"reportsCount,omitempty"`
	// The size of all the media files sent by actors from this instance
	MediaSize *int32 `json:"mediaSize,omitempty"`
	// Whether this instance has a relay, meaning that it's a Mobilizon instance that we can follow
	HasRelay *bool `json:"hasRelay,omitempty"`
}

type InstanceFeeds struct {
	// Whether the instance-wide feeds are enabled
	Enabled *bool `json:"enabled,omitempty"`
}

type InstanceFilterFollowStatus string

const (
	InstanceFilterFollowStatusAll       InstanceFilterFollowStatus = "ALL"
	InstanceFilterFollowStatusFollowing InstanceFilterFollowStatus = "FOLLOWING"
	InstanceFilterFollowStatusFollowed  InstanceFilterFollowStatus = "FOLLOWED"
)

type InstanceFilterSuspendStatus string

const (
	InstanceFilterSuspendStatusAll       InstanceFilterSuspendStatus = "ALL"
	InstanceFilterSuspendStatusSuspended InstanceFilterSuspendStatus = "SUSPENDED"
)

type InstanceFollowStatus string

const (
	// The instance follow was approved
	InstanceFollowStatusApproved InstanceFollowStatus = "APPROVED"
	// The instance follow is still pending
	InstanceFollowStatusPending InstanceFollowStatus = "PENDING"
	// There's no instance follow etablished
	InstanceFollowStatusNone InstanceFollowStatus = "NONE"
)

// The acceptable values for the instance privacy policy type
type InstancePrivacyType string

const (
	// An URL. Users will be redirected to this URL.
	InstancePrivacyTypeUrl InstancePrivacyType = "URL"
	// Privacy policy will be set to Mobilizon's default privacy policy
	InstancePrivacyTypeDefault InstancePrivacyType = "DEFAULT"
	// Custom privacy policy text
	InstancePrivacyTypeCustom InstancePrivacyType = "CUSTOM"
)

// The acceptable values for the instance's terms type
type InstanceTermsType string

const (
	// An URL. Users will be redirected to this URL.
	InstanceTermsTypeUrl InstanceTermsType = "URL"
	// Terms will be set to Mobilizon's default terms
	InstanceTermsTypeDefault InstanceTermsType = "DEFAULT"
	// Custom terms text
	InstanceTermsTypeCustom InstanceTermsType = "CUSTOM"
)

type InstancesSortFields string

const (
	InstancesSortFieldsEventCount      InstancesSortFields = "EVENT_COUNT"
	InstancesSortFieldsPersonCount     InstancesSortFields = "PERSON_COUNT"
	InstancesSortFieldsGroupCount      InstancesSortFields = "GROUP_COUNT"
	InstancesSortFieldsFollowersCount  InstancesSortFields = "FOLLOWERS_COUNT"
	InstancesSortFieldsFollowingsCount InstancesSortFields = "FOLLOWINGS_COUNT"
	InstancesSortFieldsReportsCount    InstancesSortFields = "REPORTS_COUNT"
	InstancesSortFieldsMediaSize       InstancesSortFields = "MEDIA_SIZE"
)

// A entity that can be interacted with from a remote instance
type Interactable struct {
	// A public URL for the entity
	Url *string `json:"url,omitempty"`
}

// Language information
type Language struct {
	// The iso-639-3 language code
	Code *string `json:"code,omitempty"`
	// The language name
	Name *string `json:"name,omitempty"`
}

type Location struct {
	// The range in kilometers the user wants to see events
	Range *int32 `json:"range,omitempty"`
	// A geohash representing the user's preferred location
	Geohash *string `json:"geohash,omitempty"`
	// A string describing the user's preferred  location
	Name *string `json:"name,omitempty"`
}

// The set of parameters needed to input a location
type LocationInput struct {
	// The range in kilometers the user wants to see events
	Range *int32 `json:"range,omitempty"`
	// A geohash representing the user's preferred location
	Geohash *string `json:"geohash,omitempty"`
	// A string describing the user's preferred  location
	Name *string `json:"name,omitempty"`
}

// A JWT and the associated user ID
type Login struct {
	// A JWT Token for this session
	AccessToken string `json:"accessToken"`
	// A JWT Token to refresh the access token
	RefreshToken string `json:"refreshToken"`
	// The user associated to this session
	User *User `json:"user"`
}

// Geographic coordinates
type Lonlat struct {
	// The coordinates longitude
	Longitude *float64 `json:"longitude,omitempty"`
	// The coordinates latitude
	Latitude *float64 `json:"latitude,omitempty"`
}

// Instance maps configuration
type Maps struct {
	// The instance's maps tiles configuration
	Tiles *Tiles `json:"tiles,omitempty"`
	// The instance's maps routing configuration
	Routing *Routing `json:"routing,omitempty"`
}

// A media
type Media struct {
	// The media's ID
	Id string `json:"id,omitempty"`
	// The media's alternative text
	Alt *string `json:"alt,omitempty"`
	// The media's name
	Name *string `json:"name,omitempty"`
	// The media's full URL
	Url *string `json:"url,omitempty"`
	// The media's detected content type
	ContentType *string `json:"contentType,omitempty"`
	// The media's size
	Size *int32 `json:"size,omitempty"`
	// The media's metadata
	Metadata *MediaMetadata `json:"metadata,omitempty"`
}

// An attached media or a link to a media
type MediaInput struct {
	// A full media attached
	Media *MediaInputObject `json:"media,omitempty"`
	// The ID of an existing media
	MediaId string `json:"mediaId,omitempty"`
}

// An attached media
type MediaInputObject struct {
	// The media's name
	Name string `json:"name"`
	// The media's alternative text
	Alt *string `json:"alt,omitempty"`
	// The media file
	File gqlclient.Upload `json:"file"`
	// The media owner
	ActorId string `json:"actorId,omitempty"`
}

// Some metadata associated with a media
type MediaMetadata struct {
	// The media width (if a picture)
	Width *int32 `json:"width,omitempty"`
	// The media width (if a height)
	Height *int32 `json:"height,omitempty"`
	// The media blurhash (if a picture
	Blurhash *string `json:"blurhash,omitempty"`
}

// Represents a member of a group
type Member struct {
	// The member's ID
	Id string `json:"id,omitempty"`
	// Of which the profile is member
	Parent *Group `json:"parent,omitempty"`
	// Which profile is member of
	Actor *Person `json:"actor,omitempty"`
	// The role of this membership
	Role *MemberRoleEnum `json:"role,omitempty"`
	// Who invited this member
	InvitedBy *Person `json:"invitedBy,omitempty"`
	// When was this member created
	InsertedAt *NaiveDateTime `json:"insertedAt,omitempty"`
	// When was this member updated
	UpdatedAt *NaiveDateTime `json:"updatedAt,omitempty"`
}

// Values for a member role
type MemberRoleEnum string

const (
	// The member needs to be approved by the group admins
	MemberRoleEnumNotApproved MemberRoleEnum = "NOT_APPROVED"
	// The member has been invited
	MemberRoleEnumInvited MemberRoleEnum = "INVITED"
	// Regular member
	MemberRoleEnumMember MemberRoleEnum = "MEMBER"
	// The member is a moderator
	MemberRoleEnumModerator MemberRoleEnum = "MODERATOR"
	// The member is an administrator
	MemberRoleEnumAdministrator MemberRoleEnum = "ADMINISTRATOR"
	// The member was the creator of the group. Shouldn't be used.
	MemberRoleEnumCreator MemberRoleEnum = "CREATOR"
	// The member has been rejected or excluded from the group
	MemberRoleEnumRejected MemberRoleEnum = "REJECTED"
)

// The `Naive DateTime` scalar type represents a naive date and time without
// timezone. The DateTime appears in a JSON response as an ISO8601 formatted
// string.
type NaiveDateTime string

// The list of values the for pending notification settings
type NotificationPendingEnum string

const (
	// None. The notification won't be sent.
	NotificationPendingEnumNone NotificationPendingEnum = "NONE"
	// Direct. The notification will be sent right away each time.
	NotificationPendingEnumDirect NotificationPendingEnum = "DIRECT"
	// One hour. Notifications will be sent at most each hour
	NotificationPendingEnumOneHour NotificationPendingEnum = "ONE_HOUR"
	// One day. Notifications will be sent at most each day
	NotificationPendingEnumOneDay NotificationPendingEnum = "ONE_DAY"
	// One Week. Notifications will be sent at most each week
	NotificationPendingEnumOneWeek NotificationPendingEnum = "ONE_WEEK"
)

// An oAuth Provider
type OauthProvider struct {
	// The provider ID
	Id *string `json:"id,omitempty"`
	// The label for the auth provider
	Label *string `json:"label,omitempty"`
}

// Describes how an actor is opened to follows
type Openness string

const (
	// The actor can only be followed by invitation
	OpennessInviteOnly Openness = "INVITE_ONLY"
	// The actor needs to accept the following before it's effective
	OpennessModerated Openness = "MODERATED"
	// The actor is open to followings
	OpennessOpen Openness = "OPEN"
)

// A paginated list of action logs
type PaginatedActionLogList struct {
	// A list of action logs
	Elements []*ActionLog `json:"elements,omitempty"`
	// The total number of action logs in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of activity items
type PaginatedActivityList struct {
	// A list of activities
	Elements []*Activity `json:"elements,omitempty"`
	// The total number of elements in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of comments
type PaginatedCommentList struct {
	// A list of comments
	Elements []*Comment `json:"elements,omitempty"`
	// The total number of comments in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of discussions
type PaginatedDiscussionList struct {
	// A list of discussion
	Elements []*Discussion `json:"elements,omitempty"`
	// The total number of discussions in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of events
type PaginatedEventList struct {
	// A list of events
	Elements []*Event `json:"elements,omitempty"`
	// The total number of events in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of follow group events
type PaginatedFollowedGroupEvents struct {
	// A list of follow group events
	Elements []*FollowedGroupEvent `json:"elements,omitempty"`
	// The total number of follow group events in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of follower objects
type PaginatedFollowerList struct {
	// A list of followers
	Elements []*Follower `json:"elements,omitempty"`
	// The total number of elements in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of groups
type PaginatedGroupList struct {
	// A list of groups
	Elements []*Group `json:"elements,omitempty"`
	// The total number of groups in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of instances
type PaginatedInstanceList struct {
	// A list of instances
	Elements []*Instance `json:"elements,omitempty"`
	// The total number of instances in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of medias
type PaginatedMediaList struct {
	// The list of medias
	Elements []*Media `json:"elements,omitempty"`
	// The total number of medias in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of members
type PaginatedMemberList struct {
	// A list of members
	Elements []*Member `json:"elements,omitempty"`
	// The total number of elements in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of participants
type PaginatedParticipantList struct {
	// A list of participants
	Elements []*Participant `json:"elements,omitempty"`
	// The total number of participants in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of persons
type PaginatedPersonList struct {
	// A list of persons
	Elements []*Person `json:"elements,omitempty"`
	// The total number of persons in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of posts
type PaginatedPostList struct {
	// A list of posts
	Elements []*Post `json:"elements,omitempty"`
	// The total number of posts in the list
	Total *int32 `json:"total,omitempty"`
}

type PaginatedReportList struct {
	// A list of reports
	Elements []*Report `json:"elements,omitempty"`
	// The total number of reports in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of resources
type PaginatedResourceList struct {
	// A list of resources
	Elements []*Resource `json:"elements,omitempty"`
	// The total number of resources in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of todos
type PaginatedTodoList struct {
	// A list of todos
	Elements []*Todo `json:"elements,omitempty"`
	// The total number of todos in the list
	Total *int32 `json:"total,omitempty"`
}

// A paginated list of todo-lists
type PaginatedTodoListList struct {
	// A list of todo lists
	Elements []*TodoList `json:"elements,omitempty"`
	// The total number of todo lists in the list
	Total *int32 `json:"total,omitempty"`
}

// Represents a participant to an event
type Participant struct {
	// The participation ID
	Id string `json:"id,omitempty"`
	// The event which the actor participates in
	Event *Event `json:"event,omitempty"`
	// The actor that participates to the event
	Actor *Actor `json:"actor,omitempty"`
	// The role of this actor at this event
	Role *ParticipantRoleEnum `json:"role,omitempty"`
	// The metadata associated to this participant
	Metadata *ParticipantMetadata `json:"metadata,omitempty"`
	// The datetime this participant was created
	InsertedAt *DateTime `json:"insertedAt,omitempty"`
}

// Metadata about a participant
type ParticipantMetadata struct {
	// The eventual token to leave an event when user is anonymous
	CancellationToken *string `json:"cancellationToken,omitempty"`
	// The eventual message the participant left
	Message *string `json:"message,omitempty"`
	// The participant's locale
	Locale *string `json:"locale,omitempty"`
}

// The possible values for a participant role
type ParticipantRoleEnum string

const (
	// The participant has not been approved
	ParticipantRoleEnumNotApproved ParticipantRoleEnum = "NOT_APPROVED"
	// The participant has not confirmed their participation
	ParticipantRoleEnumNotConfirmed ParticipantRoleEnum = "NOT_CONFIRMED"
	// The participant is a regular participant
	ParticipantRoleEnumParticipant ParticipantRoleEnum = "PARTICIPANT"
	// The participant is an event moderator
	ParticipantRoleEnumModerator ParticipantRoleEnum = "MODERATOR"
	// The participant is an event administrator
	ParticipantRoleEnumAdministrator ParticipantRoleEnum = "ADMINISTRATOR"
	// The participant is an event creator
	ParticipantRoleEnumCreator ParticipantRoleEnum = "CREATOR"
	// The participant has been rejected from this event
	ParticipantRoleEnumRejected ParticipantRoleEnum = "REJECTED"
)

// Participation statistics
type ParticipantStats struct {
	// The number of approved participants
	Going *int32 `json:"going,omitempty"`
	// The number of not approved participants
	NotApproved *int32 `json:"notApproved,omitempty"`
	// The number of not confirmed participants
	NotConfirmed *int32 `json:"notConfirmed,omitempty"`
	// The number of rejected participants
	Rejected *int32 `json:"rejected,omitempty"`
	// The number of simple participants (excluding creators)
	Participant *int32 `json:"participant,omitempty"`
	// The number of moderators
	Moderator *int32 `json:"moderator,omitempty"`
	// The number of administrators
	Administrator *int32 `json:"administrator,omitempty"`
	// The number of creators
	Creator *int32 `json:"creator,omitempty"`
}

// Represents a person identity
type Person struct {
	// Internal ID for this person
	Id string `json:"id,omitempty"`
	// The user this actor is associated to
	User *User `json:"user,omitempty"`
	// The list of groups this person is member of
	MemberOf []*Member `json:"memberOf,omitempty"`
	// The ActivityPub actor's URL
	Url *string `json:"url,omitempty"`
	// The type of Actor (Person, Group,…)
	Type *ActorType `json:"type,omitempty"`
	// The actor's displayed name
	Name *string `json:"name,omitempty"`
	// The actor's domain if (null if it's this instance)
	Domain *string `json:"domain,omitempty"`
	// If the actor is from this instance
	Local *bool `json:"local,omitempty"`
	// The actor's summary
	Summary *string `json:"summary,omitempty"`
	// The actor's preferred username
	PreferredUsername *string `json:"preferredUsername,omitempty"`
	// Whether the actors manually approves followers
	ManuallyApprovesFollowers *bool `json:"manuallyApprovesFollowers,omitempty"`
	// If the actor is suspended
	Suspended *bool `json:"suspended,omitempty"`
	// The actor's avatar media
	Avatar *Media `json:"avatar,omitempty"`
	// The actor's banner media
	Banner *Media `json:"banner,omitempty"`
	// Number of followers for this actor
	FollowersCount *int32 `json:"followersCount,omitempty"`
	// Number of actors following this actor
	FollowingCount *int32 `json:"followingCount,omitempty"`
	// The total size of the media from this actor
	MediaSize *int32 `json:"mediaSize,omitempty"`
	// A list of the feed tokens for this person
	FeedTokens []*FeedToken `json:"feedTokens,omitempty"`
	// A list of the events this actor has organized
	OrganizedEvents *PaginatedEventList `json:"organizedEvents,omitempty"`
	// The list of events this person goes to
	Participations *PaginatedParticipantList `json:"participations,omitempty"`
	// The list of groups this person is member of
	Memberships *PaginatedMemberList `json:"memberships,omitempty"`
	// The list of groups this person follows
	Follows *PaginatedFollowerList `json:"follows,omitempty"`
}

// Search persons result
type Persons struct {
	// Total elements
	Total int32 `json:"total"`
	// Person elements
	Elements []*Person `json:"elements"`
}

// The `Point` scalar type represents Point geographic information compliant string data,
// represented as floats separated by a semi-colon. The geodetic system is WGS 84
type Point string

// A post
type Post struct {
	// The post's ID
	Id string `json:"id,omitempty"`
	// The post's title
	Title *string `json:"title,omitempty"`
	// The post's slug
	Slug *string `json:"slug,omitempty"`
	// The post's body, as HTML
	Body *string `json:"body,omitempty"`
	// The post's URL
	Url *string `json:"url,omitempty"`
	// Whether the post is a draft
	Draft *bool `json:"draft,omitempty"`
	// The post's author
	Author *Actor `json:"author,omitempty"`
	// The post's group
	AttributedTo *Actor `json:"attributedTo,omitempty"`
	// The post's visibility
	Visibility *PostVisibility `json:"visibility,omitempty"`
	// When the post was published
	PublishAt *DateTime `json:"publishAt,omitempty"`
	// The post's creation date
	InsertedAt *DateTime `json:"insertedAt,omitempty"`
	// The post's last update date
	UpdatedAt *DateTime `json:"updatedAt,omitempty"`
	// The post language
	Language *string `json:"language,omitempty"`
	// The post's tags
	Tags []*Tag `json:"tags,omitempty"`
	// The posts's media
	Picture *Media `json:"picture,omitempty"`
}

// The list of visibility options for a post
type PostVisibility string

const (
	// Publicly listed and federated. Can be shared.
	PostVisibilityPublic PostVisibility = "PUBLIC"
	// Visible only to people with the link
	PostVisibilityUnlisted PostVisibility = "UNLISTED"
	// Visible only to people members of the group or followers of the person
	PostVisibilityPrivate PostVisibility = "PRIVATE"
)

// The instance's privacy policy configuration
type Privacy struct {
	// The instance's privacy policy URL
	Url *string `json:"url,omitempty"`
	// The instance's privacy policy type
	Type *InstancePrivacyType `json:"type,omitempty"`
	// The instance's privacy policy body text
	BodyHtml *string `json:"bodyHtml,omitempty"`
}

// Token
type RefreshedToken struct {
	// Generated access token
	AccessToken string `json:"accessToken"`
	// Generated refreshed token
	RefreshToken string `json:"refreshToken"`
}

// A report object
type Report struct {
	// The internal ID of the report
	Id string `json:"id,omitempty"`
	// The comment the reporter added about this report
	Content *string `json:"content,omitempty"`
	// Whether the report is still active
	Status *ReportStatus `json:"status,omitempty"`
	// The URI of the report
	Uri *string `json:"uri,omitempty"`
	// The actor that is being reported
	Reported *Actor `json:"reported,omitempty"`
	// The actor that created the report
	Reporter *Actor `json:"reporter,omitempty"`
	// The event that is being reported
	Event *Event `json:"event,omitempty"`
	// The comments that are reported
	Comments []*Comment `json:"comments,omitempty"`
	// The notes made on the event
	Notes []*ReportNote `json:"notes,omitempty"`
	// When the report was created
	InsertedAt *DateTime `json:"insertedAt,omitempty"`
	// When the report was updated
	UpdatedAt *DateTime `json:"updatedAt,omitempty"`
}

// A report note object
type ReportNote struct {
	// The internal ID of the report note
	Id string `json:"id,omitempty"`
	// The content of the note
	Content *string `json:"content,omitempty"`
	// The moderator who added the note
	Moderator *Actor `json:"moderator,omitempty"`
	// The report on which this note is added
	Report *Report `json:"report,omitempty"`
	// When the report note was created
	InsertedAt *DateTime `json:"insertedAt,omitempty"`
}

// The list of possible statuses for a report object
type ReportStatus string

const (
	// The report has been opened
	ReportStatusOpen ReportStatus = "OPEN"
	// The report has been closed
	ReportStatusClosed ReportStatus = "CLOSED"
	// The report has been marked as resolved
	ReportStatusResolved ReportStatus = "RESOLVED"
)

// A resource
type Resource struct {
	// The resource's ID
	Id string `json:"id,omitempty"`
	// The resource's title
	Title *string `json:"title,omitempty"`
	// The resource's summary
	Summary *string `json:"summary,omitempty"`
	// The resource's URL
	Url *string `json:"url,omitempty"`
	// The resource's URL
	ResourceUrl *string `json:"resourceUrl,omitempty"`
	// The resource's metadata
	Metadata *ResourceMetadata `json:"metadata,omitempty"`
	// The resource's creator
	Creator *Actor `json:"creator,omitempty"`
	// The resource's owner
	Actor *Actor `json:"actor,omitempty"`
	// The resource's creation date
	InsertedAt *NaiveDateTime `json:"insertedAt,omitempty"`
	// The resource's last update date
	UpdatedAt *NaiveDateTime `json:"updatedAt,omitempty"`
	// The resource's publication date
	PublishedAt *NaiveDateTime `json:"publishedAt,omitempty"`
	// The resource's type (if it's a folder)
	Type *string `json:"type,omitempty"`
	// The resource's path
	Path *string `json:"path,omitempty"`
	// The resource's parent
	Parent *Resource `json:"parent,omitempty"`
	// Children resources in folder
	Children *PaginatedResourceList `json:"children,omitempty"`
}

// The metadata associated to the resource
type ResourceMetadata struct {
	// The type of the resource
	Type *string `json:"type,omitempty"`
	// The resource's metadata title
	Title *string `json:"title,omitempty"`
	// The resource's metadata description
	Description *string `json:"description,omitempty"`
	// The resource's metadata image
	ImageRemoteUrl *string `json:"imageRemoteUrl,omitempty"`
	// The resource's metadata image width
	Width *int32 `json:"width,omitempty"`
	// The resource's metadata image height
	Height *int32 `json:"height,omitempty"`
	// The resource's author name
	AuthorName *string `json:"authorName,omitempty"`
	// The resource's author URL
	AuthorUrl *string `json:"authorUrl,omitempty"`
	// The resource's provider name
	ProviderName *string `json:"providerName,omitempty"`
	// The resource's provider URL
	ProviderUrl *string `json:"providerUrl,omitempty"`
	// The resource's author name
	Html *string `json:"html,omitempty"`
	// The resource's favicon URL
	FaviconUrl *string `json:"faviconUrl,omitempty"`
}

// A resource provider details
type ResourceProvider struct {
	// The resource provider's type
	Type *string `json:"type,omitempty"`
	// The resource provider's endpoint
	Endpoint *string `json:"endpoint,omitempty"`
	// The resource provider's software
	Software *string `json:"software,omitempty"`
}

// The instance's restrictions
type Restrictions struct {
	// Whether groups creation is allowed only for admin, not for all users
	OnlyAdminCanCreateGroups *bool `json:"onlyAdminCanCreateGroups,omitempty"`
	// Whether events creation is allowed only for groups, not for persons
	OnlyGroupsCanCreateEvents *bool `json:"onlyGroupsCanCreateEvents,omitempty"`
}

// Instance map routing configuration
type Routing struct {
	// The instance's routing type
	Type *RoutingType `json:"type,omitempty"`
}

type RoutingType string

const (
	// Redirect to openstreetmap.org's direction endpoint
	RoutingTypeOpenstreetmap RoutingType = "OPENSTREETMAP"
	// Redirect to Google Maps's direction endpoint
	RoutingTypeGoogleMaps RoutingType = "GOOGLE_MAPS"
)

// Available sort directions
type SortDirection string

const (
	// Ascending order
	SortDirectionAsc SortDirection = "ASC"
	// Descending order
	SortDirectionDesc SortDirection = "DESC"
)

// The list of sortable fields for an user list
type SortableUserField string

const (
	// The user's ID
	SortableUserFieldId SortableUserField = "ID"
)

// A statistics object
type Statistics struct {
	// The number of local users
	NumberOfUsers *int32 `json:"numberOfUsers,omitempty"`
	// The total number of events
	NumberOfEvents *int32 `json:"numberOfEvents,omitempty"`
	// The number of local events
	NumberOfLocalEvents *int32 `json:"numberOfLocalEvents,omitempty"`
	// The total number of comments
	NumberOfComments *int32 `json:"numberOfComments,omitempty"`
	// The number of local events
	NumberOfLocalComments *int32 `json:"numberOfLocalComments,omitempty"`
	// The total number of groups
	NumberOfGroups *int32 `json:"numberOfGroups,omitempty"`
	// The number of local groups
	NumberOfLocalGroups *int32 `json:"numberOfLocalGroups,omitempty"`
	// The number of this instance's followers
	NumberOfInstanceFollowers *int32 `json:"numberOfInstanceFollowers,omitempty"`
	// The number of instances this instance follows
	NumberOfInstanceFollowings *int32 `json:"numberOfInstanceFollowings,omitempty"`
}

// A tag
type Tag struct {
	// The tag's ID
	Id string `json:"id,omitempty"`
	// The tags's slug
	Slug *string `json:"slug,omitempty"`
	// The tag's title
	Title *string `json:"title,omitempty"`
	// Related tags to this tag
	Related []*Tag `json:"related,omitempty"`
}

// The instance's terms configuration
type Terms struct {
	// The instance's terms URL.
	Url *string `json:"url,omitempty"`
	// The instance's terms type
	Type *InstanceTermsType `json:"type,omitempty"`
	// The instance's terms body text
	BodyHtml *string `json:"bodyHtml,omitempty"`
}

// Instance map tiles configuration
type Tiles struct {
	// The instance's tiles endpoint
	Endpoint *string `json:"endpoint,omitempty"`
	// The instance's tiles attribution text
	Attribution *string `json:"attribution,omitempty"`
}

// A todo
type Todo struct {
	// The todo's ID
	Id string `json:"id,omitempty"`
	// The todo's title
	Title *string `json:"title,omitempty"`
	// The todo's status
	Status *bool `json:"status,omitempty"`
	// The todo's due date
	DueDate *DateTime `json:"dueDate,omitempty"`
	// The todo's creator
	Creator *Actor `json:"creator,omitempty"`
	// The todo list this todo is attached to
	TodoList *TodoList `json:"todoList,omitempty"`
	// The todos's assigned person
	AssignedTo *Actor `json:"assignedTo,omitempty"`
}

// A todo list
type TodoList struct {
	// The todo list's ID
	Id string `json:"id,omitempty"`
	// The todo list's title
	Title *string `json:"title,omitempty"`
	// The actor that owns this todo list
	Actor *Actor `json:"actor,omitempty"`
	// The todo-list's todos
	Todos *PaginatedTodoList `json:"todos,omitempty"`
}

// The `UUID` scalar type represents UUID4 compliant string data, represented as UTF-8
// character sequences. The UUID4 type is most often used to represent unique
// human-readable ID strings.
type UUID string

// An upload limits configuration
type UploadLimits struct {
	// The default limitation, in bytes
	Default *int32 `json:"default,omitempty"`
	// The avatar limitation, in bytes
	Avatar *int32 `json:"avatar,omitempty"`
	// The banner limitation, in bytes
	Banner *int32 `json:"banner,omitempty"`
}

// A local user of Mobilizon
type User struct {
	// The user's ID
	Id string `json:"id,omitempty"`
	// The user's email
	Email string `json:"email"`
	// The user's list of profiles (identities)
	Actors []*Person `json:"actors"`
	// The user's default actor
	DefaultActor *Person `json:"defaultActor,omitempty"`
	// The datetime when the user was confirmed/activated
	ConfirmedAt *DateTime `json:"confirmedAt,omitempty"`
	// The datetime the last activation/confirmation token was sent
	ConfirmationSentAt *DateTime `json:"confirmationSentAt,omitempty"`
	// The account activation/confirmation token
	ConfirmationToken *string `json:"confirmationToken,omitempty"`
	// The datetime last reset password email was sent
	ResetPasswordSentAt *DateTime `json:"resetPasswordSentAt,omitempty"`
	// The token sent when requesting password token
	ResetPasswordToken *string `json:"resetPasswordToken,omitempty"`
	// A list of the feed tokens for this user
	FeedTokens []*FeedToken `json:"feedTokens,omitempty"`
	// The role for the user
	Role *UserRole `json:"role,omitempty"`
	// The user's locale
	Locale *string `json:"locale,omitempty"`
	// The user's login provider
	Provider *string `json:"provider,omitempty"`
	// Whether the user is disabled
	Disabled *bool `json:"disabled,omitempty"`
	// The list of participations this user has
	Participations *PaginatedParticipantList `json:"participations,omitempty"`
	// The list of memberships for this user
	Memberships *PaginatedMemberList `json:"memberships,omitempty"`
	// The list of draft events this user has created
	Drafts []*Event `json:"drafts,omitempty"`
	// The suggested events from the groups this user follows
	FollowedGroupEvents *PaginatedFollowedGroupEvents `json:"followedGroupEvents,omitempty"`
	// The list of settings for this user
	Settings *UserSettings `json:"settings,omitempty"`
	// When the user previously signed-in
	LastSignInAt *DateTime `json:"lastSignInAt,omitempty"`
	// The IP adress the user previously sign-in with
	LastSignInIp *string `json:"lastSignInIp,omitempty"`
	// When the user currenlty signed-in
	CurrentSignInAt *DateTime `json:"currentSignInAt,omitempty"`
	// The IP adress the user's currently signed-in with
	CurrentSignInIp *string `json:"currentSignInIp,omitempty"`
	// The user's media objects
	Media *PaginatedMediaList `json:"media,omitempty"`
	// The total size of all the media from this user (from all their actors)
	MediaSize *int32 `json:"mediaSize,omitempty"`
	// The user's activity settings
	ActivitySettings []*ActivitySetting `json:"activitySettings,omitempty"`
}

// The list of roles an user can have
type UserRole string

const (
	// Administrator role
	UserRoleAdministrator UserRole = "ADMINISTRATOR"
	// Moderator role
	UserRoleModerator UserRole = "MODERATOR"
	// User role
	UserRoleUser UserRole = "USER"
)

// A set of user settings
type UserSettings struct {
	// The timezone for this user
	Timezone *string `json:"timezone,omitempty"`
	// Whether this user will receive an email at the start of the day of an event.
	NotificationOnDay *bool `json:"notificationOnDay,omitempty"`
	// Whether this user will receive an weekly event recap
	NotificationEachWeek *bool `json:"notificationEachWeek,omitempty"`
	// Whether this user will receive a notification right before event
	NotificationBeforeEvent *bool `json:"notificationBeforeEvent,omitempty"`
	// When does the user receives a notification about new pending participations
	NotificationPendingParticipation *NotificationPendingEnum `json:"notificationPendingParticipation,omitempty"`
	// When does the user receives a notification about a new pending membership in one of the group they're admin for
	NotificationPendingMembership *NotificationPendingEnum `json:"notificationPendingMembership,omitempty"`
	// When does the user receives a notification about new activity
	GroupNotifications *NotificationPendingEnum `json:"groupNotifications,omitempty"`
	// The user's preferred location, where they want to be suggested events
	Location *Location `json:"location,omitempty"`
}

// Users list
type Users struct {
	// Total elements
	Total int32 `json:"total"`
	// User elements
	Elements []*User `json:"elements"`
}

type WebPush struct {
	// Whether the WebPush feature is enabled
	Enabled *bool `json:"enabled,omitempty"`
	// The server's public WebPush VAPID key
	PublicKey *string `json:"publicKey,omitempty"`
}
